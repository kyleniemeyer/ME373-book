
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>5.1. Elliptic PDEs &#8212; Mechanical Engineering Methods</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"TeX": {"Macros": {"vector": ["\\vec{#1}", 1], "uvec": ["\\hat{#1}", 1], "mag": ["\\lVert#1\\rVert", 1], "cross": "\\times", "unit": ["#1~\\mathrm{#2}", 2]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="canonical" href="https://kyleniemeyer.github.io/ME373-book/content/pdes/elliptic.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5.2. Parabolic PDEs" href="parabolic.html" />
    <link rel="prev" title="5. Partial Differential Equations" href="partial-differential-equations.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Mechanical Engineering Methods</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Mechanical Engineering Methods
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Ordinary Differential Equations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../first-order.html">
   1. Solutions to 1st-order ODEs
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../numerical-methods/numerical-methods.html">
   2. Numerical Methods
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerical-methods/integrals.html">
     2.1. Numerical integrals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerical-methods/error.html">
     2.2. Error
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerical-methods/initial-value-methods.html">
     2.3. Numerical Solutions of 1st-order ODEs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerical-methods/stability.html">
     2.4. Stability and Stiffness
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../second-order/second-order.html">
   3. Second-order Ordinary Differential Equations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../second-order/analytical.html">
     3.1. Analytical Solutions to 2nd-order ODEs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../second-order/initial-value-problems.html">
     3.2. Initial-Value Problems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../second-order/numerical-methods.html">
     3.3. Numerical methods for 2nd-order ODEs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../second-order/fourier-series.html">
     3.4. Fourier Series
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../second-order/power-series.html">
     3.5. Power Series Solutions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../bvps/boundary-value-problems.html">
   4. Boundary Value Problems
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../bvps/shooting-method.html">
     4.1. Shooting Method
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../bvps/finite-difference.html">
     4.2. Finite difference method
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../bvps/eigenvalue.html">
     4.3. Eigenvalue problems
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Partial Differential Equations
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="partial-differential-equations.html">
   5. Partial Differential Equations
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     5.1. Elliptic PDEs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parabolic.html">
     5.2. Parabolic PDEs
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Sample Quizzes
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../quizzes/quiz2-IVPs.html">
   Sample Quiz 2 problems: IVPs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../quizzes/quiz3-BVPs.html">
   Sample Quiz 3 problems: BVPs
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference external" href="https://github.com/kyleniemeyer/ME373-book">
   GitHub repository
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../contributing.html">
   Contributing to Jupyter Book
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../zbibliography.html">
   Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/kyleniemeyer/ME373-book/master?urlpath=tree/book/content/pdes/elliptic.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/kyleniemeyer/ME373-book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/kyleniemeyer/ME373-book/issues/new?title=Issue%20on%20page%20%2Fcontent/pdes/elliptic.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/kyleniemeyer/ME373-book/edit/master/book/content/pdes/elliptic.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../_sources/content/pdes/elliptic.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-heat-transfer-in-a-square-plate">
   5.1.1. Example: heat transfer in a square plate
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#row-major-mapping">
   5.1.2. Row-major mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-heat-transfer-in-a-square-plate-redux">
   5.1.3. Example: heat transfer in a square plate (redux)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#neumann-derivative-boundary-conditions">
   5.1.4. Neumann (derivative) boundary conditions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#iterative-solutions-for-very-large-problems">
   5.1.5. Iterative solutions for (very) large problems
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#jacobi-method">
     5.1.5.1. Jacobi method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gauss-seidel-method">
     5.1.5.2. Gauss-Seidel method
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Elliptic PDEs</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-heat-transfer-in-a-square-plate">
   5.1.1. Example: heat transfer in a square plate
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#row-major-mapping">
   5.1.2. Row-major mapping
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-heat-transfer-in-a-square-plate-redux">
   5.1.3. Example: heat transfer in a square plate (redux)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#neumann-derivative-boundary-conditions">
   5.1.4. Neumann (derivative) boundary conditions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#iterative-solutions-for-very-large-problems">
   5.1.5. Iterative solutions for (very) large problems
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#jacobi-method">
     5.1.5.1. Jacobi method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gauss-seidel-method">
     5.1.5.2. Gauss-Seidel method
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="elliptic-pdes">
<h1><span class="section-number">5.1. </span>Elliptic PDEs<a class="headerlink" href="#elliptic-pdes" title="Permalink to this headline">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># import libraries for numerical functions and plotting
import numpy as np
import matplotlib.pyplot as plt
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide_input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># these lines are only for helping improve the display
import matplotlib_inline.backend_inline
matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;pdf&#39;, &#39;png&#39;)
plt.rcParams[&#39;figure.dpi&#39;]= 300
plt.rcParams[&#39;savefig.dpi&#39;] = 300
</pre></div>
</div>
</div>
</div>
<p>The classic example of an elliptic PDE is <strong>Laplace’s equation</strong> (yep, the same Laplace that gave us the Laplace transform), which in two dimensions for a variable <span class="math notranslate nohighlight">\(u(x,y)\)</span> is</p>
<div class="amsmath math notranslate nohighlight" id="equation-8f3aa0d9-298d-498b-80a0-0933cb5ea114">
<span class="eqno">(5.2)<a class="headerlink" href="#equation-8f3aa0d9-298d-498b-80a0-0933cb5ea114" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = \nabla^2 u = 0 \;,
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(\nabla\)</span> is del, or nabla, and represents the gradient operator: <span class="math notranslate nohighlight">\(\nabla = \frac{\partial}{\partial x} + \frac{\partial}{\partial y}\)</span>.</p>
<p>Laplace’s equation shows up in a number of physical problems, including heat transfer, fluid dynamics, and electrostatics. For example, the heat equation for conduction in two dimensions is</p>
<div class="amsmath math notranslate nohighlight" id="equation-f0c73ce1-2153-480a-bf50-c5232bcdbf2d">
<span class="eqno">(5.3)<a class="headerlink" href="#equation-f0c73ce1-2153-480a-bf50-c5232bcdbf2d" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{\partial u}{\partial t} = \alpha \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right) \;,
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(u(x,y,t)\)</span> is temperature and <span class="math notranslate nohighlight">\(\alpha\)</span> is thermal diffusivity. Steady-state heat transfer (meaning after any initial transient period) is then described by Laplace’s equation.</p>
<p>A related elliptic PDE is <strong>Poisson’s equation</strong>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-e15bf50d-c4b3-4430-bae6-9c3b1e9da490">
<span class="eqno">(5.4)<a class="headerlink" href="#equation-e15bf50d-c4b3-4430-bae6-9c3b1e9da490" title="Permalink to this equation">#</a></span>\[\begin{equation}
\nabla^2 u = f(x,y) \;,
\end{equation}\]</div>
<p>which also appears in multiple physical problems—most notably, when solving for pressure in the Navier–Stokes equations.</p>
<p>To numerically solve these equations, and any elliptic PDE, we can use finite differences, where we replace the continuous <span class="math notranslate nohighlight">\(x,y\)</span> domain with a discrete grid of points. This is similar to what we did with boundary-value problems in one dimension—but now we have two dimensions.</p>
<p>To approximate the second derivatives in Laplace’s equation, we can use central differences in both the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> directions, applied around the <span class="math notranslate nohighlight">\(u_{i,j}\)</span> point:</p>
<div class="amsmath math notranslate nohighlight" id="equation-f0e9fa77-ce65-4414-939c-d3fe11c838c0">
<span class="eqno">(5.5)<a class="headerlink" href="#equation-f0e9fa77-ce65-4414-939c-d3fe11c838c0" title="Permalink to this equation">#</a></span>\[\begin{align}
\frac{\partial^2 u}{\partial x^2} &amp;\approx \frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{\Delta x^2} \\
\frac{\partial^2 u}{\partial y^2} &amp;\approx \frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{\Delta y^2}
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(i\)</span> is the index used in the <span class="math notranslate nohighlight">\(x\)</span> direction, <span class="math notranslate nohighlight">\(j\)</span> is the index in the <span class="math notranslate nohighlight">\(y\)</span> direction, and <span class="math notranslate nohighlight">\(\Delta x\)</span> and <span class="math notranslate nohighlight">\(\Delta y\)</span> are the step sizes in the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> directions.
In other words, <span class="math notranslate nohighlight">\(x_i = (i-1) \Delta x\)</span> and <span class="math notranslate nohighlight">\(y_j = (j-1) \Delta y\)</span>.</p>
<p>The following figure shows the points necessary to approximate the partial derivatives in the PDE at a location <span class="math notranslate nohighlight">\((x_i, y_j)\)</span>, for a general 2D region. This is known as a <strong>five-point stencil</strong>:</p>
<figure class="align-default" id="fig-stencil">
<a class="bg-primary mb-1 reference internal image-reference" href="../../_images/five-point-stencil.png"><img alt="five-point stencil" class="bg-primary mb-1" src="../../_images/five-point-stencil.png" style="width: 350px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.1 </span><span class="caption-text">Five-point finite difference stencil</span><a class="headerlink" href="#fig-stencil" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Applying these finite differences gives us an approximation for Laplace’s equation:</p>
<div class="amsmath math notranslate nohighlight" id="equation-e7588b58-34df-4aeb-845f-2349fb001069">
<span class="eqno">(5.6)<a class="headerlink" href="#equation-e7588b58-34df-4aeb-845f-2349fb001069" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{\Delta x^2} + \frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{\Delta y^2} = 0 \;.
\end{equation}\]</div>
<p>If we use a uniform grid where <span class="math notranslate nohighlight">\(\Delta x = \Delta y = h\)</span>, then we can simplify to</p>
<div class="amsmath math notranslate nohighlight" id="equation-561b832c-1aee-4028-baaa-243a92b2119e">
<span class="eqno">(5.7)<a class="headerlink" href="#equation-561b832c-1aee-4028-baaa-243a92b2119e" title="Permalink to this equation">#</a></span>\[\begin{equation}
u_{i+1,j} + u_{i,j+1} + u_{i-1,j} + u_{i,j-1} - 4 u_{i,j} = 0 \;.
\end{equation}\]</div>
<section id="example-heat-transfer-in-a-square-plate">
<h2><span class="section-number">5.1.1. </span>Example: heat transfer in a square plate<a class="headerlink" href="#example-heat-transfer-in-a-square-plate" title="Permalink to this headline">#</a></h2>
<p>As an example, let’s consider the problem of steady-state heat transfer in a square solid object. If <span class="math notranslate nohighlight">\(u(x,y)\)</span> is temperature, then this is described by Laplace’s equation:</p>
<div class="amsmath math notranslate nohighlight" id="equation-de092e85-e679-476f-b238-04f7995bcac3">
<span class="eqno">(5.8)<a class="headerlink" href="#equation-de092e85-e679-476f-b238-04f7995bcac3" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = \nabla^2 u = 0 \;,
\end{equation}\]</div>
<p>and we can solve this using finite differences. Using a uniform grid where <span class="math notranslate nohighlight">\(\Delta x = \Delta y = h\)</span>, Laplace’s equation gives us a recursion formula that relates the values at neighboring points:</p>
<div class="amsmath math notranslate nohighlight" id="equation-80badce7-bd92-47b5-948d-0d1665fdb241">
<span class="eqno">(5.9)<a class="headerlink" href="#equation-80badce7-bd92-47b5-948d-0d1665fdb241" title="Permalink to this equation">#</a></span>\[\begin{equation}
u_{i+1,j} + u_{i,j+1} + u_{i-1,j} + u_{i,j-1} - 4 u_{i,j} = 0 \;.
\end{equation}\]</div>
<p>Consider a case where the square has sides of length <span class="math notranslate nohighlight">\(L\)</span>, and the boundary conditions are that the temperature is fixed at 100 on the left, right, and bottom sides, and fixed at 0 on the top.
For now, we’ll use two segments to discretize the domain in each directions, giving us nine total points in the grid.
The following figures show the example problem, and the grid of points we’ll use.</p>
<figure class="align-default" id="fig-heat-transfer-square">
<a class="bg-white mb-1 reference internal image-reference" href="../../_images/heat-transfer-square.png"><img alt="Heat transfer in a square" class="bg-white mb-1" src="../../_images/heat-transfer-square.png" style="width: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.2 </span><span class="caption-text">Heat transfer in a square object</span><a class="headerlink" href="#fig-heat-transfer-square" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-grid-three">
<a class="bg-white mb-1 reference internal image-reference" href="../../_images/heat-equation-grid.png"><img alt="3x3 grid of points" class="bg-white mb-1" src="../../_images/heat-equation-grid.png" style="width: 300px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.3 </span><span class="caption-text">Simple 3x3 grid of points</span><a class="headerlink" href="#fig-grid-three" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Using the above recursion formula, we can write an equation for each of the nine unknown points (in the interior, not the boundary points):</p>
<div class="amsmath math notranslate nohighlight" id="equation-ea358116-9f8b-4b92-ac5c-f472b83040de">
<span class="eqno">(5.10)<a class="headerlink" href="#equation-ea358116-9f8b-4b92-ac5c-f472b83040de" title="Permalink to this equation">#</a></span>\[\begin{align}
u_{0,0} &amp;= 100 \\
u_{1,0} &amp;= 100 \\
u_{2,0} &amp;= 100 \\
u_{0,1} &amp;= 100 \\
\text{for } u_{1,1}: \quad u_{2,1} + u_{1,2} + u_{0,1} + u_{1,0} - 4u_{1,1} &amp;= 0 \\
u_{2,1} &amp;= 100 \\
u_{0,2} &amp;= 100 \\
u_{1,2} &amp;= 0 \\
u_{2,2} &amp;= 100
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(u_{i,j}\)</span> are the unknowns. Note that in this we used the side boundary condition values for the corner points <span class="math notranslate nohighlight">\(u_{0,2}\)</span> and <span class="math notranslate nohighlight">\(u_{2,2}\)</span>, rather than the top value. (In reality this would represent a discontinuity in temperature, so these aren’t very realistic boundary conditions.)</p>
<p>This is a system of linear equations, that we can represent as a matrix-vector product:</p>
<div class="amsmath math notranslate nohighlight" id="equation-dbf5b6bb-6816-46d0-9ff4-48b8ff352e36">
<span class="eqno">(5.11)<a class="headerlink" href="#equation-dbf5b6bb-6816-46d0-9ff4-48b8ff352e36" title="Permalink to this equation">#</a></span>\[\begin{align}
\begin{bmatrix} 
1 &amp; 0 &amp; 0 &amp; 0 &amp;  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp;  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp;  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp;  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; -4 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp;  0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp;  0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp;  0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp;  0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\end{bmatrix}
\begin{bmatrix} u_{0,0} \\ u_{1,0} \\ u_{2,0} \\ u_{0,1} \\ u_{1,1} \\ u_{2,1} \\ u_{0,2} \\ u_{1,2} \\ u_{2,2} \end{bmatrix} &amp;= 
\begin{bmatrix} 100 \\ 100 \\ 100 \\ 
100 \\ 0 \\ 100 \\
100 \\ 0 \\ 100 \end{bmatrix} \\
\text{or} \quad A \mathbf{u} &amp;= \mathbf{b}
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(9\times 9\)</span> coefficient matrix, <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> is a nine-element vector of unknown variables, and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> is a nine-element right-hand side vector.
For <span class="math notranslate nohighlight">\(\mathbf{u}\)</span>, we had to take variables that physically represent points in a two-dimensional space and combine them in some order to form a one-dimensional column vector. Here, we used a <strong>row-major</strong> mapping, where we started with the point in the first row and first column, then added the remaining points in that row, before moving to the next row and repeating. We’ll discuss this a bit more later.</p>
<p>If we set this up in Python, we can solve using <code class="docutils literal notranslate"><span class="pre">np.linalg.solve()</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>A = np.array([
    [1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 1, 0, 1,-4, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ])

b = np.array([100, 100, 100, 100, 0, 100, 100, 0, 100])
u = np.linalg.solve(A, b)
print(u)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[100. 100. 100. 100.  75. 100. 100.   0. 100.]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># alternatively, for creating the A matrix, we could create
# a diagonal matrix of ones and then only modify the one row
# that needs it
A = np.eye(9)
A[4, 1] = 1
A[4, 3] = 1
A[4, 4] = -4
A[4, 5] = 1
A[4, 7] = 1
u2 = np.linalg.solve(A, b)
assert np.all(u == u2)
</pre></div>
</div>
</div>
</div>
<p>This gives us the values for temperature at each of the nine points. In this example, we really only have one unknown temperature: <span class="math notranslate nohighlight">\(u_{1,1}\)</span>, located in the middle. Does the value given make sense? We can check by rearranging the recursion formula for Laplace’s equation:</p>
<div class="amsmath math notranslate nohighlight" id="equation-2dd4bfb8-01b5-45a8-af72-d6e20ec6dcf1">
<span class="eqno">(5.12)<a class="headerlink" href="#equation-2dd4bfb8-01b5-45a8-af72-d6e20ec6dcf1" title="Permalink to this equation">#</a></span>\[\begin{equation}
u_{i,j} = \frac{u_{i+1,j} + u_{i,j+1} + u_{i-1,j} + u_{i,j-1}}{4} \;,
\end{equation}\]</div>
<p>which shows that in such problems the value of the middle point should be the average of the four surrounding points. This matches the value of 75 found above.</p>
<p>We can use a contour plot to visualize the results, though we’ll need to convert the one-dimensional solution array into a two-dimensional matrix to plot. The NumPy <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.reshape.html"><code class="docutils literal notranslate"><span class="pre">reshape()</span></code></a> function can help us here: it can reshapes a one-dimensional array into a two-dimensional array, by specifying the target number of desired rows and columns:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Example of using the reshape method, with a simple array 
# going from 1 to 10

# We want to convert it into a 2D array with 2 row and 5 columns.
# The expected output is:
# [[0, 1, 2, 3, 4],
#  [5, 6, 7, 8, 9]]

b = np.array(range(10))
A = np.reshape(b, [2, 5])
print(A)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0 1 2 3 4]
 [5 6 7 8 9]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># We can use the reshape function to convert the calculated 
# temperatures into a 3x3 array:

num_x = 3
num_y = 3
u_square = np.reshape(u, [num_y, num_x])

plt.contourf(u_square, levels=10)
plt.colorbar()
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/elliptic_9_0.png" src="../../_images/elliptic_9_0.png" />
</div>
</div>
<p>Overall that looks correct: the boundary conditions are right, and we see that the center is the average of the boundaries.</p>
<p>But, clearly only using nine points (with eight of those being boundary conditions) doesn’t give us a very good solution. To make this more accurate, we’ll need to use more points, which also means we need to automate the construction of the system of equations.</p>
</section>
<section id="row-major-mapping">
<h2><span class="section-number">5.1.2. </span>Row-major mapping<a class="headerlink" href="#row-major-mapping" title="Permalink to this headline">#</a></h2>
<p>For a two-dimensional elliptic PDE like Laplace’s equation, we can generate a general recursion formula, but we need a way to take a grid of points where location is defined by row and column index and map these into a one-dimensional column vector, which has its own index.</p>
<p>The following figure shows a general 2D grid of points, with <span class="math notranslate nohighlight">\(n\)</span> number of columns in the <span class="math notranslate nohighlight">\(x\)</span> direction (using index <span class="math notranslate nohighlight">\(i\)</span>) and <span class="math notranslate nohighlight">\(m\)</span> number of rows in the <span class="math notranslate nohighlight">\(y\)</span> direction (using index <span class="math notranslate nohighlight">\(j\)</span>):</p>
<figure class="align-default" id="fig-twodim-grid">
<a class="bg-white mb-1 reference internal image-reference" href="../../_images/row-major.png"><img alt="2D grid of points" class="bg-white mb-1" src="../../_images/row-major.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.4 </span><span class="caption-text">2D grid of points with <em>n</em> columns and <em>m</em> columns.</span><a class="headerlink" href="#fig-twodim-grid" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>We want to convert the rows and columns of <span class="math notranslate nohighlight">\(u_{i,j}\)</span> points defined by column and row index into a single column array using a different index, <span class="math notranslate nohighlight">\(k\)</span> (this choice is arbitrary):</p>
<div class="amsmath math notranslate nohighlight" id="equation-ffd26350-a19c-47d1-9979-a9c6395ab9d2">
<span class="eqno">(5.13)<a class="headerlink" href="#equation-ffd26350-a19c-47d1-9979-a9c6395ab9d2" title="Permalink to this equation">#</a></span>\[\begin{equation}
\begin{bmatrix} u_{0,0} \\ u_{1,0} \\ u_{2,0} \\ \vdots \\ u_{n-1,0} \\
u_{0,1} \\ u_{1,1} \\ u_{2,1} \\ \vdots \\ u_{n-1, 1} \\ u_{0,2} \\ \vdots \\
u_{0,m-1} \\ u_{1,m-1} \\ \vdots \\ u_{n-1,m-1}
\end{bmatrix}
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> refers to the index used in that array.</p>
<p>To do this mapping, we can use this formula:</p>
<div class="amsmath math notranslate nohighlight" id="equation-2890047d-6ab7-48d2-a035-0561bfa8f4d7">
<span class="eqno">(5.14)<a class="headerlink" href="#equation-2890047d-6ab7-48d2-a035-0561bfa8f4d7" title="Permalink to this equation">#</a></span>\[\begin{equation}
k_{i,j} = j n + i
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_{i,j}\)</span> refers to the 1D index <span class="math notranslate nohighlight">\(k\)</span> mapped from the 2D indices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
<figure class="align-default" id="fig-grid-three2">
<a class="bg-primary mb-1 reference internal image-reference" href="../../_images/heat-equation-grid.png"><img alt="3x3 grid of points" class="bg-primary mb-1" src="../../_images/heat-equation-grid.png" style="width: 250px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.5 </span><span class="caption-text">Simple 3x3 grid of points</span><a class="headerlink" href="#fig-grid-three2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>For example, in this <span class="math notranslate nohighlight">\(3\times 3\)</span> grid, where <span class="math notranslate nohighlight">\(n=3\)</span> and <span class="math notranslate nohighlight">\(m=3\)</span>, consider the point where <span class="math notranslate nohighlight">\(i=1\)</span> and <span class="math notranslate nohighlight">\(j=1\)</span> (the point right in the center).
Using our formula,</p>
<div class="amsmath math notranslate nohighlight" id="equation-9cb3ccd2-17d9-4fb1-aeec-9ffc136fef72">
<span class="eqno">(5.15)<a class="headerlink" href="#equation-9cb3ccd2-17d9-4fb1-aeec-9ffc136fef72" title="Permalink to this equation">#</a></span>\[\begin{equation}
k_{1,1} = (1) 3 + 1 = 4
\end{equation}\]</div>
<p>which matches what we can visually confirm: the fifth point, which would have index 4.</p>
<p>Using that mapping, we can also identify the 1D indices associated with the points surrounding location <span class="math notranslate nohighlight">\((i,j)\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-52faadea-a909-4001-a6ff-49d46d306fc3">
<span class="eqno">(5.16)<a class="headerlink" href="#equation-52faadea-a909-4001-a6ff-49d46d306fc3" title="Permalink to this equation">#</a></span>\[\begin{align}
k_{i-1,j} &amp;= j n + i - 1 \\
k_{i+1,j} &amp;= j n + i + 1 \\
k_{i,j-1} &amp;= (j-1)n + i \\
k_{i,j+1} &amp;= (j+1) n + i
\end{align}\]</div>
<p>which we can use to determine the appropriate locations to place values in the coefficient and right-hand side matrices.</p>
</section>
<section id="example-heat-transfer-in-a-square-plate-redux">
<h2><span class="section-number">5.1.3. </span>Example: heat transfer in a square plate (redux)<a class="headerlink" href="#example-heat-transfer-in-a-square-plate-redux" title="Permalink to this headline">#</a></h2>
<p>Let’s return to the example of steady-state heat transfer in a square plate—but this time we’ll set the solution up more generally so we can vary the step size <span class="math notranslate nohighlight">\(h = \Delta x = \Delta y\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>h = 0.1
length_x = 1.0
length_y = 1.0
x_vals = np.arange(0, length_x + 0.001, h)
y_vals = np.arange(0, length_y + 0.001, h)

# The coefficient matrix A is now m*n by m*n, 
# since that is the total number of points.
# The right-hand side vector b is m*n by 1.
A = np.zeros((len(x_vals)*len(y_vals), len(x_vals)*len(y_vals)))
b = np.zeros(len(x_vals)*len(y_vals))

u_left = 100
u_right = 100
u_bottom = 100
u_top = 0

for j, y in enumerate(y_vals):
    for i, x in enumerate(x_vals):
        # for convenience, calculate all indices now
        kij = j*len(x_vals) + i
        kim1j = j*len(x_vals) + i - 1
        kip1j = j*len(x_vals) + i + 1
        kijm1 = (j-1)*len(x_vals) + i
        kijp1 = (j+1)*len(x_vals) + i
        if i == 0:
            # this is the left boundary
            A[kij, kij] = 1
            b[kij] = u_left
        elif i == len(x_vals) - 1:
            # right boundary
            A[kij, kij] = 1
            b[kij] = u_right
        elif j == 0:
            # bottom boundary
            A[kij, kij] = 1
            b[kij] = u_bottom
        elif j == len(y_vals) - 1:
            # top boundary
            A[kij, kij] = 1
            b[kij] = u_top
        else:
            # coefficients for interior points, based
            # on the recursion formula
            A[kij, kim1j] = 1
            A[kij, kip1j] = 1
            A[kij, kijm1] = 1
            A[kij, kijp1] = 1
            A[kij, kij] = -4
u = np.linalg.solve(A, b)

u_square = np.reshape(u, (len(y_vals), len(x_vals)))
plt.contourf(x_vals, y_vals, u_square, levels=10)
plt.colorbar(label=&#39;Temperature&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/elliptic_13_0.png" src="../../_images/elliptic_13_0.png" />
</div>
</div>
</section>
<section id="neumann-derivative-boundary-conditions">
<h2><span class="section-number">5.1.4. </span>Neumann (derivative) boundary conditions<a class="headerlink" href="#neumann-derivative-boundary-conditions" title="Permalink to this headline">#</a></h2>
<p>So far, we have only discussed cases where we have Dirichlet boundary conditions; in other words, when we have all fixed values at the boundary. Frequently we also encounter Neumann-style boundary conditions, where we have the <em>derivative</em> specified at the boundary.</p>
<p>We can handle this in the same way we do for one-dimensional boundary value problems: either with a forward or backward difference (both of which are first-order accurate), or with a central difference using an imaginary point/ghost node (which is second-order accurate). Let’s focus on using the central difference, since it is more accurate.</p>
<figure class="align-default" id="fig-ghost-node">
<a class="bg-primary mb-1 reference internal image-reference" href="../../_images/2d-ghost-node.png"><img alt="ghost node at boundary" class="bg-primary mb-1" src="../../_images/2d-ghost-node.png" style="width: 250px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.6 </span><span class="caption-text">Ghost/imaginary node beyond an upper boundary</span><a class="headerlink" href="#fig-ghost-node" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>For example, let’s say that at the upper boundary, the derivative of temperature is zero:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5b11ffa3-7c91-41c0-ab0d-956d56ff3127">
<span class="eqno">(5.17)<a class="headerlink" href="#equation-5b11ffa3-7c91-41c0-ab0d-956d56ff3127" title="Permalink to this equation">#</a></span>\[\begin{equation}
\left. \frac{\partial u}{\partial y} \right|_{\text{boundary}} = 0
\end{equation}\]</div>
<p>Let’s consider this boundary condition applied at the point shown, <span class="math notranslate nohighlight">\(u_{2,3}\)</span>.
We can approximate this derivative using a central difference:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5b4743c2-0177-4f83-a440-f4060c4396e3">
<span class="eqno">(5.18)<a class="headerlink" href="#equation-5b4743c2-0177-4f83-a440-f4060c4396e3" title="Permalink to this equation">#</a></span>\[\begin{align}
\frac{u_{2,3}}{\partial y} \approx \frac{u_{2,4} - u_{2,2}}{\Delta x} &amp;= 0 \\
u_{2,4} &amp;= u_{2,2}
\end{align}\]</div>
<p>This tells us the value of the point above the boundary, <span class="math notranslate nohighlight">\(u_{2,4}\)</span>; however, this point is a “ghost” or imaginary point located outside the boundary, so we don’t really care about its value. Instead, we can use this relationship to give us a usable equation for the boundary point, by incorporating it into the normal recursion formula for Laplace’s equation:</p>
<div class="amsmath math notranslate nohighlight" id="equation-4eb10ac3-2908-46da-ba99-0da47e5cc67b">
<span class="eqno">(5.19)<a class="headerlink" href="#equation-4eb10ac3-2908-46da-ba99-0da47e5cc67b" title="Permalink to this equation">#</a></span>\[\begin{align}
u_{1,3} + u_{3,3} + u_{2,4} + u_{2,2} - 4u_{2,3} &amp;= 0 \\
u_{1,3} + u_{3,3} + u_{2,2} + u_{2,2} - 4u_{2,3} &amp;= 0 \\
\rightarrow u_{1,3} + u_{3,3} + 2 u_{2,2} - 4u_{2,3} &amp;= 0
\end{align}\]</div>
<p>The recursion formula for points along the upper boundary would then become</p>
<div class="amsmath math notranslate nohighlight" id="equation-4c46eeb5-92bc-4ef1-b91e-c43804a7389f">
<span class="eqno">(5.20)<a class="headerlink" href="#equation-4c46eeb5-92bc-4ef1-b91e-c43804a7389f" title="Permalink to this equation">#</a></span>\[\begin{equation}
u_{i+1,j} + u_{i-1,j} + 2 u_{i,j-1} - 4 u_{i,j} = 0 \;.
\end{equation}\]</div>
<p>Now let’s try solving the above example, but with <span class="math notranslate nohighlight">\(\frac{\partial u}{\partial y} = 0\)</span> at the top boundary and <span class="math notranslate nohighlight">\(u = 0\)</span> at the bottom boundary:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>h = 0.1
length_x = 1.0
length_y = 1.0
x_vals = np.arange(0, length_x + 0.001, h)
y_vals = np.arange(0, length_y + 0.001, h)

# The coefficient matrix A is now m*n by m*n, 
# since that is the total number of points.
# The right-hand side vector b is m*n by 1.
A = np.zeros((len(x_vals)*len(y_vals), len(x_vals)*len(y_vals)))
b = np.zeros(len(x_vals)*len(y_vals))

u_left = 100
u_right = 100
u_bottom = 0
# u_top is not needed, insulated BC

for j, y in enumerate(y_vals):
    for i, x in enumerate(x_vals):
        # for convenience, calculate all indices now
        kij = j*len(x_vals) + i
        kim1j = j*len(x_vals) + i - 1
        kip1j = j*len(x_vals) + i + 1
        kijm1 = (j-1)*len(x_vals) + i
        kijp1 = (j+1)*len(x_vals) + i
        if i == 0:
            # this is the left boundary
            A[kij, kij] = 1
            b[kij] = u_left
        elif i == len(x_vals) - 1:
            # right boundary
            A[kij, kij] = 1
            b[kij] = u_right
        elif j == 0:
            # bottom boundary
            A[kij, kij] = 1
            b[kij] = u_bottom
        elif j == len(y_vals) - 1:
            # top boundary, using the ghost node + recursion formula            
            A[kij, kim1j] = 1
            A[kij, kip1j] = 1
            A[kij, kijm1] = 2
            A[kij, kij] = -4
        else:
            # coefficients for interior points, based
            # on the recursion formula
            A[kij, kim1j] = 1
            A[kij, kip1j] = 1
            A[kij, kijm1] = 1
            A[kij, kijp1] = 1
            A[kij, kij] = -4
u = np.linalg.solve(A, b)

u_square = np.reshape(u, (len(y_vals), len(x_vals)))
plt.contourf(x_vals, y_vals, u_square, levels=20)
plt.colorbar(label=&#39;Temperature&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/elliptic_15_0.png" src="../../_images/elliptic_15_0.png" />
</div>
</div>
</section>
<section id="iterative-solutions-for-very-large-problems">
<h2><span class="section-number">5.1.5. </span>Iterative solutions for (very) large problems<a class="headerlink" href="#iterative-solutions-for-very-large-problems" title="Permalink to this headline">#</a></h2>
<p>So far, we’ve been able to solve our systems of linear equations in Python by using <code class="docutils literal notranslate"><span class="pre">np.linalg.solve()</span></code>, which directly finds the solution to the equation <span class="math notranslate nohighlight">\(A \mathbf{y} = \mathbf{b}\)</span>.</p>
<p>However, this approach will become very slow as the grid resolution (<span class="math notranslate nohighlight">\(h = \Delta x = \Delta y\)</span>) becomes smaller, and eventually unfeasable due to the associated computational requirements. First, let’s create a function that takes as input the segment size <span class="math notranslate nohighlight">\(h\)</span>, then returns the time it takes to solve the problem for different sizes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import time 

def heat_equation(h):
    &#39;&#39;&#39;Solves 2D steady heat equation problem given step size&#39;&#39;&#39;
    t0 = time.time()
    
    length_x = 1.0
    length_y = 1.0
    x_vals = np.arange(0, length_x + 0.001, h)
    y_vals = np.arange(0, length_y + 0.001, h)
    
    num_pts = len(x_vals)*len(y_vals)

    # The coefficient matrix A is now m*n by m*n, 
    # since that is the total number of points.
    # The right-hand side vector b is m*n by 1.
    A = np.zeros((num_pts, num_pts))
    b = np.zeros(num_pts)

    u_left = 100
    u_right = 100
    u_bottom = 100
    u_top = 0

    for j, y in enumerate(y_vals):
        for i, x in enumerate(x_vals):
            # for convenience, calculate all indices now
            kij = j*len(x_vals) + i
            kim1j = j*len(x_vals) + i - 1
            kip1j = j*len(x_vals) + i + 1
            kijm1 = (j-1)*len(x_vals) + i
            kijp1 = (j+1)*len(x_vals) + i
            if i == 0:
                # this is the left boundary
                A[kij, kij] = 1
                b[kij] = u_left
            elif i == len(x_vals) - 1:
                # right boundary
                A[kij, kij] = 1
                b[kij] = u_right
            elif j == 0:
                # bottom boundary
                A[kij, kij] = 1
                b[kij] = u_bottom
            elif j == len(y_vals) - 1:
                # top boundary
                A[kij, kij] = 1
                b[kij] = u_top
            else:
                # coefficients for interior points, based
                # on the recursion formula
                A[kij, kim1j] = 1
                A[kij, kip1j] = 1
                A[kij, kijm1] = 1
                A[kij, kijp1] = 1
                A[kij, kij] = -4
    u = np.linalg.solve(A, b)
    u_square = np.reshape(u, (len(y_vals), len(x_vals)))
    
    return num_pts, (time.time() - t0)
</pre></div>
</div>
</div>
</div>
<p>Now, we can see how long it takes to solve as we increase the resolution, and get an idea about the relationship between time-to-solution and number of unknowns.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>step_sizes = [0.2, 0.1, 0.05, 0.025, 0.02, 0.0125, 0.01]

num_pts = np.zeros(len(step_sizes))
times = np.zeros_like(num_pts)
for idx, step_size in enumerate(step_sizes):
    num_pts[idx], times[idx] = heat_equation(step_size)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.loglog(num_pts, times, &#39;o&#39;, label=&#39;Actual cost&#39;)
#plt.loglog(nums, times, &#39;-o&#39;)
plt.xlabel(&#39;Number of unknowns&#39;); 
plt.ylabel(&#39;Time for direct solution (sec)&#39;)

x = num_pts[:]
n2 = x**2 * (times[1] / x[1]**2) 
n3 = x**3 * (times[1] / x[1]**3)
plt.loglog(x, n2, &#39;--&#39;, label=&#39;quadratic&#39;)
plt.loglog(x, n3, &#39;--&#39;, label=&#39;cubic&#39;)

plt.legend()
plt.grid(True)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/elliptic_20_0.png" src="../../_images/elliptic_20_0.png" />
</div>
</div>
<p>After about 100 points/unknowns, the cost begins increasing exponentially with the number of points, somewhere between quadratic (<span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span>) and cubic (<span class="math notranslate nohighlight">\(\mathcal{O}(n^3)\)</span>).</p>
<p>If we try to reduce the step size further, for example to 0.005, we’ll see that we cannot get a solution in a reasonable amount of time. But, clearly we want to get solutions for large numbers of unknowns, so what can we do?</p>
<p>We can solve larger systems of linear equations using <em>iterative</em> methods. There are a number of these, and we’ll focus on two:</p>
<ul class="simple">
<li><p>Jacobi method</p></li>
<li><p>Gauss-Seidel method</p></li>
</ul>
<section id="jacobi-method">
<h3><span class="section-number">5.1.5.1. </span>Jacobi method<a class="headerlink" href="#jacobi-method" title="Permalink to this headline">#</a></h3>
<p>The Jacobi method essentially works by starting with an initial guess to the solution, then using the recursion formula to solve for values at each point, then repeating this until the values converge (i.e., stop changing).</p>
<p>An algorithm we can use to solve Laplace’s equation:</p>
<ol class="simple">
<li><p>Set some initial guess for all unknowns: <span class="math notranslate nohighlight">\(u_{i,j}^{\text{old}}\)</span></p></li>
<li><p>Set the boundary values</p></li>
<li><p>For each point in the interior, use the recursion formula to solve for new values based on old values at the surrounding points: <span class="math notranslate nohighlight">\(u_{i,j} = \left( u_{i+1,j}^{\text{old}} + u_{i-1,j}^{\text{old}} + u_{i,j+1}^{\text{old}} + u_{i,j-1}^{\text{old}} \right)/4\)</span>.</p></li>
<li><p>Check for convergence: is <span class="math notranslate nohighlight">\(\epsilon\)</span> less than some tolerance, such as <span class="math notranslate nohighlight">\(10^{-6}\)</span>? Where <span class="math notranslate nohighlight">\(\epsilon = \max \left| u_{i,j} - u_{i,j}^{\text{old}} \right|\)</span>. If no, then return to step 2 and repeat.</p></li>
</ol>
<p>More formally, if we have a system <span class="math notranslate nohighlight">\(A \mathbf{x} = \mathbf{b}\)</span>, where</p>
<div class="amsmath math notranslate nohighlight" id="equation-ea522132-8ce5-441a-9721-11a22d650d85">
<span class="eqno">(5.21)<a class="headerlink" href="#equation-ea522132-8ce5-441a-9721-11a22d650d85" title="Permalink to this equation">#</a></span>\[\begin{equation}
A = \begin{bmatrix}
a_{0,0} &amp; a_{0,1} &amp; \cdots &amp; a_{0,n-1} \\
a_{1,0} &amp; a_{1,1} &amp; \cdots &amp; a_{1,n-1} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n-1,0} &amp; a_{n-1,1} &amp; \cdots &amp; a_{n-1,n-1} \end{bmatrix}
\quad \mathbf{x} = \begin{bmatrix} x_0 \\ x_1 \\ \vdots \\ x_{n-1} \end{bmatrix}
\quad \mathbf{b} = \begin{bmatrix} b_0 \\ b_1 \\ \vdots \\ b_{n-1} \end{bmatrix}
\end{equation}\]</div>
<p>then we can solve iterative for <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> using</p>
<div class="amsmath math notranslate nohighlight" id="equation-dcc04f21-4af4-4998-94ac-7041bd737256">
<span class="eqno">(5.22)<a class="headerlink" href="#equation-dcc04f21-4af4-4998-94ac-7041bd737256" title="Permalink to this equation">#</a></span>\[\begin{equation}
x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j \neq i} a_{ij} x_j^{(k)} \right) , \quad i = 0,1,\ldots, n-1
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_i^{(k)}\)</span> is a value of the solution at iteration <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(x_i^{(k+1)}\)</span> is at the next iteration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def heat_equation_jacobi(h):
    &#39;&#39;&#39;Solves heat equation using Jacobi iteration&#39;&#39;&#39;
    t0 = time.time()
    
    length_x = 1.0
    length_y = 1.0
    x_vals = np.arange(0, length_x + 0.001, h)
    y_vals = np.arange(0, length_y + 0.001, h)
    
    num_pts = len(x_vals)*len(y_vals)

    # initial guess
    u = 100 * np.ones(num_pts)

    u_left = 100
    u_right = 100
    u_bottom = 100
    u_top = 0
    
    # dummy value for residual variable
    epsilon = 1.0
    
    num_iter = 0
    while epsilon &gt; 1e-2:
        u_old = np.copy(u)
        epsilon = 0.0

        for j, y in enumerate(y_vals):
            for i, x in enumerate(x_vals):
                # for convenience, calculate all indices now
                kij = j*len(x_vals) + i
                kim1j = j*len(x_vals) + i - 1
                kip1j = j*len(x_vals) + i + 1
                kijm1 = (j-1)*len(x_vals) + i
                kijp1 = (j+1)*len(x_vals) + i
                if i == 0:
                    # this is the left boundary
                    u[kij] = u_left
                elif i == len(x_vals) - 1:
                    # right boundary
                    u[kij] = u_right
                elif j == 0:
                    # bottom boundary
                    u[kij] = u_bottom
                elif j == len(y_vals) - 1:
                    # top boundary
                    u[kij] = u_top
                else:
                    # interior points
                    u[kij] = (
                        u_old[kip1j] + u_old[kim1j] + 
                        u_old[kijm1] + u_old[kijp1]
                        ) / 4.0
        epsilon = np.max(np.abs(u - u_old))
        num_iter += 1
    
    u_square = np.reshape(u, (len(y_vals), len(x_vals)))
    # use a dict to package a large number of return objects
    solution = {&#39;num_points&#39;: num_pts,
                &#39;time&#39;: time.time() - t0,
                &#39;num_iter&#39;: num_iter,
                &#39;u&#39;: u_square,
                &#39;x&#39;: x_vals,
                &#39;y&#39;: y_vals
                }
    
    return solution
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>step_sizes = [0.2, 0.1, 0.05, 0.025, 0.02, 0.0125, 0.01, 0.005]

num_pts_jac = np.zeros(len(step_sizes))
times_jac = np.zeros_like(num_pts_jac)
num_iter_jac = np.zeros_like(num_pts_jac)
for idx, step_size in enumerate(step_sizes):
    sol = heat_equation_jacobi(step_size)
    num_pts_jac[idx] = sol[&#39;num_points&#39;]
    times_jac[idx] = sol[&#39;time&#39;]
    num_iter_jac[idx] = sol[&#39;num_iter&#39;]
    x_vals = sol[&#39;x&#39;]
    y_vals = sol[&#39;y&#39;]
    u = sol[&#39;u&#39;]
    print(f&quot;Number of iterations: {sol[&#39;num_iter&#39;]}&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of iterations: 33
Number of iterations: 107
Number of iterations: 317
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of iterations: 822
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of iterations: 1062
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of iterations: 1637
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of iterations: 1910
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyboardInterrupt</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">line</span> <span class="mi">7</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span> <span class="n">num_iter_jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">num_pts_jac</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">step_size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">step_sizes</span><span class="p">):</span>
<span class="ne">----&gt; </span><span class="mi">7</span>     <span class="n">sol</span> <span class="o">=</span> <span class="n">heat_equation_jacobi</span><span class="p">(</span><span class="n">step_size</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">8</span>     <span class="n">num_pts_jac</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;num_points&#39;</span><span class="p">]</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span>     <span class="n">times_jac</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>

<span class="nn">Cell In[12], line 33,</span> in <span class="ni">heat_equation_jacobi</span><span class="nt">(h)</span>
<span class="g g-Whitespace">     </span><span class="mi">31</span> <span class="n">kij</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>
<span class="g g-Whitespace">     </span><span class="mi">32</span> <span class="n">kim1j</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
<span class="ne">---&gt; </span><span class="mi">33</span> <span class="n">kip1j</span> <span class="o">=</span> <span class="n">j</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="g g-Whitespace">     </span><span class="mi">34</span> <span class="n">kijm1</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>
<span class="g g-Whitespace">     </span><span class="mi">35</span> <span class="n">kijp1</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>

<span class="ne">KeyboardInterrupt</span>: 
</pre></div>
</div>
</div>
</div>
</section>
<section id="gauss-seidel-method">
<h3><span class="section-number">5.1.5.2. </span>Gauss-Seidel method<a class="headerlink" href="#gauss-seidel-method" title="Permalink to this headline">#</a></h3>
<p>The Gauss-Seidel method is very similar to the Jacobi method, but with one important difference: rather than using all old values to calculate the new values, incorporate updated values as they are available. Because the method incorporates newer information more quickly, it tends to converge faster (meaning, with fewer iterations) than the Jacobi method.</p>
<p>Formally, if we have a system <span class="math notranslate nohighlight">\(A \mathbf{x} = \mathbf{b}\)</span>, where</p>
<div class="amsmath math notranslate nohighlight" id="equation-e9599a73-b74f-479a-ac63-29c9e9c87a22">
<span class="eqno">(5.23)<a class="headerlink" href="#equation-e9599a73-b74f-479a-ac63-29c9e9c87a22" title="Permalink to this equation">#</a></span>\[\begin{equation}
A = \begin{bmatrix}
a_{0,0} &amp; a_{0,1} &amp; \cdots &amp; a_{0,n-1} \\
a_{1,0} &amp; a_{1,1} &amp; \cdots &amp; a_{1,n-1} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{n-1,0} &amp; a_{n-1,1} &amp; \cdots &amp; a_{n-1,n-1} \end{bmatrix}
\quad \mathbf{x} = \begin{bmatrix} x_0 \\ x_1 \\ \vdots \\ x_{n-1} \end{bmatrix}
\quad \mathbf{b} = \begin{bmatrix} b_0 \\ b_1 \\ \vdots \\ b_{n-1} \end{bmatrix}
\end{equation}\]</div>
<p>then we can solve iterative for <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> using</p>
<div class="amsmath math notranslate nohighlight" id="equation-60e2821a-be53-4cfb-9172-6c6c50db955b">
<span class="eqno">(5.24)<a class="headerlink" href="#equation-60e2821a-be53-4cfb-9172-6c6c50db955b" title="Permalink to this equation">#</a></span>\[\begin{equation}
x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - \sum_{j =i+1}^n a_{ij} x_j^{(k)} \right) , \quad i = 0,1,\ldots, n-1
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\(x_i^{(k)}\)</span> is a value of the solution at iteration <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(x_i^{(k+1)}\)</span> is at the next iteration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def heat_equation_gauss_seidel(h):
    &#39;&#39;&#39;Solves heat equation using the Gauss-Seidel method&#39;&#39;&#39;
    t0 = time.time()
    
    length_x = 1.0
    length_y = 1.0
    x_vals = np.arange(0, length_x + 0.001, h)
    y_vals = np.arange(0, length_y + 0.001, h)
    
    num_pts = len(x_vals)*len(y_vals)

    # initial guess
    u = 100 * np.ones(num_pts)

    u_left = 100
    u_right = 100
    u_bottom = 100
    u_top = 0
    
    # dummy value for residual variable
    epsilon = 1.0
    
    num_iter = 0
    while epsilon &gt; 1e-2:
        u_old = np.copy(u)
        epsilon = 0.0

        for j, y in enumerate(y_vals):
            for i, x in enumerate(x_vals):
                # for convenience, calculate all indices now
                kij = j*len(x_vals) + i
                kim1j = j*len(x_vals) + i - 1
                kip1j = j*len(x_vals) + i + 1
                kijm1 = (j-1)*len(x_vals) + i
                kijp1 = (j+1)*len(x_vals) + i
                if i == 0:
                    # this is the left boundary
                    u[kij] = u_left
                elif i == len(x_vals) - 1:
                    # right boundary
                    u[kij] = u_right
                elif j == 0:
                    # bottom boundary
                    u[kij] = u_bottom
                elif j == len(y_vals) - 1:
                    # top boundary
                    u[kij] = u_top
                else:
                    # interior points
                    u[kij] = (
                        u[kip1j] + u[kim1j] + 
                        u[kijm1] + u[kijp1]
                        ) / 4.0
        epsilon = np.max(np.abs(u - u_old))
        num_iter += 1
    
    u_square = np.reshape(u, (len(y_vals), len(x_vals)))
    # use a dict to package a large number of return objects
    solution = {&#39;num_points&#39;: num_pts,
                &#39;time&#39;: time.time() - t0,
                &#39;num_iter&#39;: num_iter,
                &#39;u&#39;: u_square,
                &#39;x&#39;: x_vals,
                &#39;y&#39;: y_vals
                }
    
    return solution
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>step_sizes = [0.2, 0.1, 0.05, 0.025, 0.02, 0.0125, 0.01, 0.005]

num_pts_gs = np.zeros(len(step_sizes))
times_gs = np.zeros_like(num_pts_gs)
num_iter_gs = np.zeros_like(num_pts_gs)
for idx, step_size in enumerate(step_sizes):
    sol = heat_equation_gauss_seidel(step_size)
    num_pts_gs[idx] = sol[&#39;num_points&#39;]
    times_gs[idx] = sol[&#39;time&#39;]
    num_iter_gs[idx] = sol[&#39;num_iter&#39;]
    x_vals = sol[&#39;x&#39;]
    y_vals = sol[&#39;y&#39;]
    u = sol[&#39;u&#39;]
    print(f&quot;Number of iterations: {sol[&#39;num_iter&#39;]}&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of iterations: 21
Number of iterations: 64
Number of iterations: 193
Number of iterations: 533
Number of iterations: 716
Number of iterations: 1224
Number of iterations: 1502
Number of iterations: 2275
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.loglog(num_pts, times, &#39;-o&#39;, label=&#39;Direct solution&#39;)
plt.loglog(num_pts_jac, times_jac, &#39;-^&#39;, label=&#39;Jacobi solution&#39;)
plt.loglog(num_pts_gs, times_gs, &#39;-x&#39;, label=&#39;Gauss-Seidel solution&#39;)
plt.xlabel(&#39;Number of unknowns&#39;)
plt.ylabel(&#39;Time for solution (sec)&#39;)
plt.legend()
plt.grid()
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/elliptic_28_0.png" src="../../_images/elliptic_28_0.png" />
</div>
</div>
<p>We can see that for smaller numbers of points/unknowns, the direct solution method is faster, but at some point the costs of solving directly (meaning using linear algebra) grow higher.</p>
<p>Due to time and computer memory constraints, we can’t actually show that the direct method takes longer for the smallest step size (0.005)—many computers will run out of memory!</p>
<p>In addition, if you look at the slopes of the costs, the iterative methods have a consistent slope, while the direct method changes slope to grow in cost faster at a certain point.</p>
<p>(Running these tests on different computers might generate slightly different results, but the overall conclusions should stay the same.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.loglog(num_pts_jac, num_iter_jac, &#39;-^&#39;, label=&#39;Jacobi method&#39;)
plt.loglog(num_pts_gs, num_iter_gs, &#39;-x&#39;, label=&#39;Gauss-Seidel method&#39;)
plt.xlabel(&#39;Number of unknowns&#39;)
plt.ylabel(&#39;Number of iterations required&#39;)
plt.legend()
plt.grid()
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/elliptic_30_0.png" src="../../_images/elliptic_30_0.png" />
</div>
</div>
<p>These results show us a few things:</p>
<ul class="simple">
<li><p>For small problem sizes, the direct solution method is faster.</p></li>
<li><p>For the heat equation, once we get to around 10000 unknowns, the methods perform similarly. Beyond this, the direct solution method becomes unreasonably slow, and fails to solve in a reasonable time for a step size of 0.005.</p></li>
<li><p>The Gauss-Seidel method generally converges with around half the number of iterations than the Jacobi method.</p></li>
</ul>
<p>For larger, more-realistic problems, iterative solution methods like Jacobi and Gauss-Seidel are essential.</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content/pdes"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="partial-differential-equations.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">5. </span>Partial Differential Equations</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="parabolic.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">5.2. </span>Parabolic PDEs</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Kyle Niemeyer<br/>
  
    <div class="extra_footer">
      <p xmlns:dct="http://purl.org/dc/terms/" xmlns:cc="http://creativecommons.org/ns#" class="license-text"><a rel="cc:attributionURL" property="dct:title" href="https://github.com/kyleniemeyer/ME373-book">Mechanical Engineering Methods notes</a> by <span property="cc:attributionName">Kyle Niemeyer</span> is licensed under <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" /><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" /><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" /></a></p>

    </div>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>